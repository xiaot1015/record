### 第六节 memcache 相关
随着并发请求的增加，磁盘I／O的瓶颈很快就体现出来，
然而数据在内存中比从磁盘中读要快很多，缺点是数据不6易持久保存，
memcached 简单的k-v 模式的nosql，在很多地方都能体现其优势。
缓存的简单的使用 就不说了。在此学习下memchaed的内在

[1] memcache 多路复用I／o 消息模式，使其中一个链接超时的情况下不会阻塞其他的链接。
[2] memcache 的多线程跟cpu的核数有关，一般情况设置成cpu的赫数 效率更高。
## slab 分配算法保存数据
原理是把1m 的空间分割成多个chunk  也就是一个slab
即 将40 个1m 的空间 按照不同的 chunk空间  分割
40中不同的slab 第二个slab是地一个slab 的1.25倍， 然后基于字节对其的鬼子。 chunk快的大小必须被8整除。 
方便使用。

#删除的规则   LRU算法
依据FIFO 的原则
一段时间未访问的 会被先剔除掉。 过期的在访问的时候才会被删除
命中为0的会被先剔除掉， 
 
MEM 工作原理。
一个主线程 主要接受accept 信号，然后将信号推送到队列中， 然后其他线程从队列中读取。

#MEM 的一致hash分布 相关

在服务器数量不便的情况下， 使用一般性hash分布就能满足， 但是当增加服务器的时候就得使用一致性hash分布了。 
hash 算： md5 一个key 生成一个32位的字符串，22
在一个2^32-1 环里面，分布这多台服务器， 当有connect 进来的时候 会依照环的顺序找到服务器，当需要新增服务器的时候，在环上新增。
影响的只是要被改动的一段逆时针方向到下一个服务器之间的数据， 删除也是同理

# 注意
一致性hash存在数据平衡性问题， 可以在环上设置一些虚拟的节点，然后这些节点对应到实际的对象中。


